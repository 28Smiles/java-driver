# Reference configuration for the DataStax Java driver for Apache CassandraÂ®.
#
# Unless you use a custom mechanism to load your configuration (see DriverContext), all the values
# declared here will be used as defaults if you don't override them in your own `application.conf`.
#
# This file is in HOCON format, see https://github.com/typesafehub/config/blob/master/HOCON.md.
datastax-java-driver {
  # The contact points to use for the initial connection to the cluster.
  #
  # These are addresses of Cassandra nodes that the driver uses to discover the cluster topology.
  # Only one contact point is required (the driver will retrieve the address of the other nodes
  # automatically), but it is usually a good idea to provide more than one contact point, because
  # if that single contact point is unavailable, the driver cannot initialize itself correctly.
  #
  # This must be a list of strings with each contact point specified as "host:port". If the host is
  # a DNS name that resolves to multiple A-records, all the corresponding addressess will be used.
  # Do not use "localhost" as the host name (since it resolves to both IPv4 and IPv6 addresses on
  # some platforms).
  #
  # Note that the current version of Cassandra (3.11) requires all nodes in a cluster to share the
  # same port.
  #
  # Contact points can also be provided programmatically when you build a cluster instance. If both
  # are specified, they will be merged.
  // contact-points = [ "127.0.0.1:9042", "127.0.0.2:9042" ]

  protocol {
    # The native protocol version to use.
    #
    # This option is not required. If it is absent, the driver will negotiate it with the *first*
    # node it tries to connect to. More precisely, it will try with the highest supported version,
    # and if not supported fallback to the second highest and so on.
    # Once the version is set, it will be used for the lifetime of the driver instance.
    # Auto detection can be problematic with mixed-version clusters: if the driver connects first
    # to one of the higher-version nodes, it will negotiate a version that might not work when
    # connecting to lower-version nodes later. You should force the lowest common protocol version
    # in that case.
    // version = V4
  }

  # A name that uniquely identifies the driver instance created from this configuration. This is
  # used as a prefix for log messages and metrics.
  # This parameter is optional; if it is not specified, the driver will generate an identifier
  # composed of the letter 'c' followed by an incrementing counter.
  # If you provide a different value, try to keep it short to keep the logs readable. Also, make
  # sure it is unique: reusing the same value will not break the driver, but it will mix up the logs
  # and metrics.
  // cluster-name = my_cluster

  # How often the driver tries to reload the configuration.
  # To disable periodic reloading, set this to 0.
  config-reload-interval = 5 minutes

  retry-policy {
    class = com.datastax.oss.driver.api.core.retry.DefaultRetryPolicy
  }

  load-balancing-policy {
    class = com.datastax.oss.driver.api.core.loadbalancing.RoundRobinLoadBalancingPolicy
  }

  speculative-execution-policy {
    class = com.datastax.oss.driver.api.core.specex.NoSpeculativeExecutionPolicy
  }

  connection {
    # The timeout to use for internal queries that run as part of the initialization process, just
    # after we open a connection. If this timeout fires, the initialization of the connection will
    # fail. If this is the first connection ever, the driver will fail to initialize as well,
    # otherwise it will retry the connection later.
    init-query-timeout = 500 milliseconds

    # The timeout to use when the driver changes the keyspace on a connection at runtime (this
    # happens when the client issues a `USE ...` query, and all connections belonging to the
    # current session need to be updated).
    set-keyspace-timeout = ${datastax-java-driver.connection.init-query-timeout}

    # The maximum number of requests that can be executed concurrently on a connection.
    # This must be between 1 and 32768.
    max-requests-per-connection = 32768

    heartbeat {
      # The heartbeat interval. If a connection stays idle for that duration (no reads), the driver
      # sends a dummy message on it to make sure it's still alive. If not, the connection is
      # trashed and replaced.
      interval = 30 seconds
      # How long the driver waits for the response to a heartbeat. If this timeout fires, the
      # heartbeat is considered failed.
      timeout = ${datastax-java-driver.connection.init-query-timeout}
    }
    # The maximum length of the frames supported by the driver. Beyond that limit, requests will
    # fail with an exception
    max-frame-length = 256 MB

    reconnection-policy {
      class = com.datastax.oss.driver.api.core.connection.ExponentialReconnectionPolicy
      base-delay = 1 second
      max-delay = 60 seconds
    }

    control-connection {
      # How long the driver waits for responses to control queries (e.g. fetching the list of
      # nodes, refreshing the schema).
      timeout = 500 milliseconds
      # The page size used for control queries. If a query returns more than this number of
      # results, it will be fetched in multiple requests.
      page-size = 5000
    }
  }

  request {
    # How long the driver waits for a request to complete. This is a global limit on the duration
    # of a session.execute() call, including any internal retries the driver might do.
    timeout = 500 milliseconds

    # The consistency level.
    consistency = ONE

    # The page size. This controls how many rows will be retrieved simultaneously in a single
    # network roundtrip (the goal being to avoid loading too many results in memory at the same
    # time). If there are more results, additional requests will be used to retrieve them (either
    # automatically if you iterate with the sync API, or explicitly with the async API's
    # fetchNextPage method).
    # If the value is 0 or negative, it will be ignored and the request will not be paged.
    page-size = 5000

    # The serial consistency level.
    # The allowed values are SERIAL and LOCAL_SERIAL.
    serial-consistency = SERIAL

    # Whether a warning is logged when a request (such as a CQL `USE ...`) changes the active
    # keyspace.
    # Switching keyspace at runtime is highly discouraged, because it is inherently unsafe (other
    # requests expecting the old keyspace might be running concurrently), and may cause statements
    # prepared before the change to fail.
    # It should only be done in very specific use cases where there is only a single client thread
    # executing synchronous queries (such as a cqlsh-like interpreter). In other cases, clients
    # should prefix table names in their queries instead.
    #
    # Note that CASSANDRA-10145 (scheduled for C* 4.0) will introduce a per-request keyspace
    # option as a workaround to this issue.
    warn-if-set-keyspace = true

    # The default idempotence of a request, that will be used for all `Request` instances where
    # `isIdempotent()` returns null.
    default-idempotence = false
  }

  prepared-statements {
    # Whether `Session.prepare` calls should be sent to all nodes in the cluster.
    #
    # A request to prepare is handled in two steps:
    # 1) send to a single node first (to rule out simple errors like malformed queries).
    # 2) if step 1 succeeds, re-send to all other active nodes (i.e. not ignored by the load
    # balancing policy).
    # This option controls whether step 2 is executed.
    #
    # The reason why you might want to disable it is to optimize network usage if you have a large
    # number of clients preparing the same set of statements at startup. If your load balancing
    # policy distributes queries randomly, each client will pick a different host to prepare its
    # statements, and on the whole each host has a good chance of having been hit by at least one
    # client for each statement.
    # On the other hand, if that assumption turns out to be wrong and one host hasn't prepared a
    # given statement, it needs to be re-prepared on the fly the first time it gets executed; this
    # causes a performance penalty (one extra roundtrip to resend the query to prepare, and another
    # to retry the execution).
    prepare-on-all-nodes = true

    # How the driver replicates prepared statements on a node that just came back up or joined the
    # cluster.
    reprepare-on-up {
      # Whether the driver tries to prepare on new nodes at all.
      #
      # The reason why you might want to disable it is to optimize reconnection time when you
      # believe nodes often get marked down because of temporary network issues, rather than the
      # node really crashing. In that case, the node still has prepared statements in its cache when
      # the driver reconnects, so re-preparing is redundant.
      #
      # On the other hand, if that assumption turns out to be wrong and the node had really
      # restarted, its prepared statement cache is empty (before CASSANDRA-8831), and statements
      # need to be re-prepared on the fly the first time they get executed; this causes a
      # performance penalty (one extra roundtrip to resend the query to prepare, and another to
      # retry the execution).
      enabled = true
      # Whether to check `system.prepared_statements` on the target node before repreparing.
      #
      # This table exists since CASSANDRA-8831 (merged in 3.10). It stores the statements already
      # prepared on the node, and preserves them across restarts.
      #
      # Checking the table first avoids repreparing unnecessarily, but the cost of the query is not
      # always worth the improvement, especially if the number of statements is low.
      check-system-table = false
      # The maximum number of statements that should be reprepared. 0 or a negative value means no
      # limit.
      max-statements = 0
      # The maximum number of concurrent requests when repreparing.
      max-parallelism = 100
      # The request timeout. This applies both to querying the system.prepared_statements table (if
      # relevant), and the prepare requests themselves.
      timeout = ${datastax-java-driver.connection.init-query-timeout}
    }
  }

  # The driver maintains a connection pool to each node, according to the distance assigned to it
  # by the load balancing policy. If the distance is IGNORED, no connections are maintained.
  pooling {
    local {
      # The number of connections in the pool.
      connections = 1
    }
    remote {
      connections = 1
    }
  }

  metadata {
    # Topology events are external signals that inform the driver of the state of Cassandra nodes
    # (by default, they correspond to gossip events received on the control connection).
    # The debouncer helps smoothen out oscillations if conflicting events are sent out in short
    # bursts.
    # Debouncing may be disabled by setting the window to 0 or max-events to 1 (this is not
    # recommended).
    topology-event-debouncer {
      # How long the driver waits to propagate an event. If another event is received within that
      # time, the window is reset and a batch of accumulated events will be delivered.
      window = 1 second
      # The maximum number of events that can accumulate. If this count is reached, the events are
      # delivered immediately and the time window is reset. This avoids holding events indefinitely
      # if the window keeps getting reset.
      max-events = 20
    }
  }
  # The address translator to use to convert the addresses sent by Cassandra nodes into ones that
  # the driver uses to connect.
  # This is only needed if the nodes are not directly reachable from the driver (for example, the
  # driver is in a different network region and needs to use a public IP, or it connects through
  # a proxy).
  address-translator {
    # This default implementation always returns the same address unchanged.
    class = com.datastax.oss.driver.api.core.addresstranslation.PassThroughAddressTranslator
  }
  # The auth provider that will handle authentication for each new connection to a server.
  auth-provider {
    # This property is optional; if it is not present, no authentication will occur.
    // class = com.datastax.driver.api.core.auth.PlainTextAuthProvider
    # Sample configuration for the plain-text provider:
    // username = cassandra
    // password = cassandra
  }
  # The SSL engine factory that will initialize an SSL engine for each new connection to a server.
  ssl-engine-factory {
    # This property is optional; if it is not present, SSL won't be activated.
    // class = com.datastax.driver.api.core.ssl.DefaultSslEngineFactory
    # Sample configuration for the default SSL factory:
    # The cipher suites to enable when creating an SSLEngine for a connection.
    # This property is optional. If it is not present, the driver won't explicitly enable cipher
    # suites on the engine, which according to the JDK documentations results in "a minimum
    # quality of service".
    // cipher-suites = [ "TLS_RSA_WITH_AES_128_CBC_SHA", "TLS_RSA_WITH_AES_256_CBC_SHA" ]
  }
}