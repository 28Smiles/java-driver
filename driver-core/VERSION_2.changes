API Changes
-----------

- Statement must now implement 2 new methods: Statement#getKeyspace() and
  Statement#getValues(). If you defined a class that directly extend Statement,
  you will have to implement those methods, even though both can return null
  if they are not useful in your case.

- The Metadata#getReplicas() method now takes 2 arguments. You must now provide
  the keyspace on top of the partition key (the previous behavior was buggy,
  it's impossible to return the full list of replica for a partition key
  without knowing the keyspace since replication depends on the keyspace).

- The method LoadBalancingPolicy#newQueryPlan() method now takes the currently
  logged keyspace as 2nd argument (in addition to the query object). This
  information is actually necessary to do proper token aware balancing.

- NoHostAvaiableException#getErrors() now return the full exception for each
  node. In other words, it return a Map<InetAddress, Throwable> instead of
  a Map<InetAddress, String>.

- Query#getConsistencyLevel() will now return null by default, which means "use
  the default consistency level". That default consistency level can now be
  configured (through the new QueryOptions object in the cluster Configuration).

- The deprecated since 1.0.2, Host.HealtMonitor class has been removed. You will
  now need to use Host#isUp and Cluster#register if you were using that class.

- The Cluster.Initializer interface should now implement 2 new methods:
  getInitialListeners() (which can return an empty collection) and getClusterName
  (which can return null).

- The Metrics class now uses Codahale metrics library version 3. That new major
  version of the library has many API changes compare to the previous used
  version 2. This may have impact on users of that class. Besides, the
  default JmxReporter now includes a name specific to the cluster instance in the
  ObjectName (to avoid conflict if multiple Cluster instance are created in the
  same JVM), so tools that were polling JMX information may have to be updated
  accordingly.

- The Cluster and Session shutdown API have changed. There is now only one
  shutdown() method that is asynchronous and return a Future on the completeion
  of shutdown.

- The ResultSetFuture#set and ResultSetFuture#setException methods have been removed
  (from the public API at least) as they were never meant to be exposed publicly: a
  resultSetFuture is always set by the driver himself and should not be set manually.

- Creating the Cluster instance (through Cluster#buildFrom or the Cluster.Builder#build method)
  does not create any connection right away anymore and thus cannot throw a
  NoHostAvailableException (nor an AuthenticationException) anymore. Instead, the initial
  contact points are checked the first time a call to Cluster#connect is done.
  If you want to for some reason, a new Cluster#init method allows to emulate the
  v1 behavior: Cluster.builder().build() in v1 is equivalent to
  Cluster.builder().build().init() in v2.

- The class Query has been renamed Statement (as it was confusing to some that "BoundStatement"
  was not a "Statement"). To allow this, the old "Statement" class has been renamed to
  "RegularStatement". You might have to adapt your code accordingly.

- The QueryBuilder#raw method does not automatically add quotes anymore, but rather ouptut
  its result without an change (as the raw name implies). This means for instance that
  eq("x", raw(foo)) will output "x = foo", not "x = 'foo'" (you don't need the raw method
  to output the latter string).

- The QueryBuilder#in method now has the following special case: using
  QueryBuilder.in(QueryBuilder.bindMarker()) will generate the string "IN ?", not "IN (?)"
  as was the case in v1. While the first syntax is not currently valid, it will be once
  https://issues.apache.org/jira/browse/CASSANDRA-4210 is solved. When that's the case,
  that "IN ?" syntax will be a lot more util than "IN (?)" for which using an equality
  is simpler anyway. This change is done now so as to avoid breaking the compatibility in
  a minor release. Note that if you really want to create "IN (?)" in the query builder
  for some obscure reason, you can use QueryBuilder.in(QueryBuilder.raw("?")).

- The UnavailableException#getConsistency method has been renamed to getConsistencyLevel
  for consistency with QueryTimeoutException.


New Features
------------

- A new BatchStatement class has been added. It allows to execute other
  statements as in a BATCH. The main use case is to batch multiple prepared
  statements when the number of said statement is not known in advance (i.e.
  you cannot or it is inconvenient to prepare a CQL BATCH statement in the
  first place).

- SimpleStatement can now take a list of values in addtion to the query. This
  allows to do the equivalent of a prepare+execute but in only one round-trip
  to the server and without keeping the prepared statement after the execution.
  This is useful if a given should be executed only once (i.e. you don't want to
  prepare it) but you also don't want to serialize all values into strings.
  Shortcut Session#execute() and Session#executeAsync() methods are also
  provided for that case.

- SELECT queries are now "paged" under the hood. The size of each "page" can be
  controlled through Query#setFetchSize(). In general, paging should be
  transparent, more results will be automatically fetched (if relevant) once a
  given page of results has been retrieved from the resultSet. However ResultSet
  provides 2 methods to query the state of that paging:
  ResultSet#getAvailableWithoutFetching() and ResultSet#isFullyFetched(). You can
  also force the prefetching of pages somewhat through the use of
  ResultSet#fetchMoreResults.

- LZ4 compression is supported
